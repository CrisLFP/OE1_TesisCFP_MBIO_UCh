---
title: "OE2_RIM"
author: "CFP"
format: html
editor: visual
---

```{r}
gc()
setwd("~/Desktop/U_CHILE/MG_BIOESTADIÃÅSTICA/TESIS/DATOS PUÃÅBLICOS/OE2")
```

```{r}
library(tidyverse)     ## adm de datos
library(lme4)          ## modelos mixtos Poisson.
library(lmerTest)      ## pruebas para modelos mixtos, EL PAQUETE DE PREDICCION NO TIENE INCORPORADO POISSON, DESCARTADO
library(summarytools)  ## libreria de res√∫menes.
library(yardstick)     ## para ver errores
library(merTools)      ## intervalos de predicci√≥n NO TIENE INCORCOPORADO POISSON, DESCARTADO
library(glmmTMB)       ## intervalos de predicci√≥n, TIENE INCORPORADO POISSON
library(DHARMa)        ## analisis de residuos
library(marginaleffects)       ## efectos marginales.
library(easystats)      ## evaluacipon del modelo
```

# Estimaci√≥n de casos de CG por SS

```{r}
## Para dar cumplimiento a este objetivo es necesario ajustar el modelo lineal mixto con intercepto aleatorio para la variable de servicio de salud.

## Recordar que lo que se est√° modelando es la RIM, raz√≥n incidencia/mortalidad, la cual se asume que es constante en los servicios de Salud.

## el modelo estima utiliza como variables explicatorias el sexo y quinquenio para servicio de salud y causa espec√≠fica (en este caso es solo CG)
```

# 1. Datos por quinquenio y sexo

## 1.1. Incidencias.

```{r}
## Carga de datos de incidencia
incidencias <- read_csv("incidencias_oe2.csv")%>%
  mutate(SEXO = as.factor(SEXO)) %>%
  mutate(SEXO = fct_recode(SEXO,                 ## renombrar niveles de variables
                                "Hombre" = "1",  ## "nombre nuevo" = "nombre viejo"
                                "Mujer" = "2"))
head(incidencias)

inc_matriz <- incidencias %>%
  group_by(Servicio_salud, A√ëO) %>%
  summarise(incidencias = sum(incidencias), .groups = "drop") %>%
  pivot_wider(
    names_from = A√ëO,
    values_from = incidencias
  ) %>%
  dplyr::select(Servicio_salud,  all_of(sort(names(.)[-1])))
as.matrix(inc_matriz)
```

## 1.2. Defunciones.

```{r}
## carga de datos de defunciones
defunciones <- read_csv("defunciones_oe2.csv")
head(defunciones)
```

# 2. C√°lculo de RIM

```{r}
## calculo de raz√≥n incidencia mortalidad.
rim <- left_join(incidencias, defunciones, by = c("Servicio_salud",
                                                  "A√ëO",
                                                  "SEXO",
                                                  "QUINQUENIO"))
rim <- rim %>%
  mutate(RIM = round(incidencias/Defunciones,2))  %>% ## esta es la estructura que utiliza estad√≠stica del minsal
  filter( A√ëO >=2002)
```

# 3. Graficos RIM

```{r fig.width=8, fig.height=15}

## Graficar las RIM por a√±o y SS
 plot1 <- rim %>%
  
  ## seleccion variables a estudiar
  dplyr::select(Servicio_salud, SEXO, QUINQUENIO, A√ëO, Defunciones, incidencias) %>%
  
  ## agrupar por SS y A√ëO
  group_by(Servicio_salud, A√ëO) %>%
  
  ## resumir incidencias y defunciones, como la suma de los valores de las respectivas columnas
  summarise(
    inc = sum(incidencias),
    def = sum(Defunciones, 
              na.rm = T) ## aqu√≠ hay valores NA por lo que deben ser removidos
  ) %>%
  
  ## creaci√≥n de la variables RIM.1
  mutate(RIM.1 = round(def/inc,2))


## Gr√°fico
rim.plot <-  ggplot(plot1, # df de donde se obtienen los datos
       aes(x = A√ëO,                     # eje x : variable A√ëO
           y = RIM.1,                    # eje y: varibale tasa
           group = Servicio_salud,      # agrupar por la variables Servicio_salud
           color = Servicio_salud)) +   # color segun Servicio_salud
  geom_smooth(method = "lm",
              se = F,
              linetype = "solid",
              colour = "#8B8878",
              alpha = 0.05,
              linewidth = 0.6) +
  geom_line() +                         # L√≠nea de incidencia por a√±o
  geom_point() +                        # Puntos para visualizar las tasas
  facet_wrap(~ Servicio_salud, 
             scales = "fixed",
             ncol = 1) +  # Un gr√°fico por servicio de salud
  scale_x_continuous(breaks = unique(plot1$A√ëO)) + 
  theme_minimal() +
  theme(legend.position = "none") +  # Oculta la leyenda porque cada faceta es un servicio
  labs(title = "Raz√≥n Mortalidad/Incidencia de GC por a√±o en Servicios de Salud", 
       x = "A√±o", 
       y = "RIM") #+
  
  #coord_cartesian(ylim = c(0.3, 1.8))  ## Cambia el rango (0, 100) seg√∫n lo que se necesite

rim.plot

 ## ggsave("rim_plot_1.jpeg", Rim.plot, width = 8, height = 10, dpi = 300)

```

```{r  fig.width=8 ,fig.height= 10}
## Graficar las RIM por a√±o, SS y tramo etario

plot2 <- rim %>%
  
  ## agrupar datos por SS, A√ëO y QUINQUENIO
  group_by(Servicio_salud, A√ëO, QUINQUENIO) %>%
  
  ## resumir el conteo de incidencias y defunciones
  summarise(
    inc = sum(incidencias),
    def = sum(Defunciones, 
              na.rm = T) ## aqu√≠ hay valores NA por lo que deben ser removidos (para el gr√°fico)
  ) %>%
  
  ## creacion de la variables RIM.2
  mutate(RIM.2 = ifelse(def == 0,                         ## si las defunciones son 0
                              NA,                         ## las reemplaza por un NA
                              round(def / inc, 2))) %>%   ## en otro caso hace esta operacion. De esta forma se evita dividir por 0 cuando el grupo etario no tiene casos.
  
  ## filtar valores infinitos
  filter(!is.infinite(RIM.2)) ## si aparece un infinito lo elimina


## necesito graficar la rim por SS por a√±o y quinquenio (en pizarra)
## en el eje Y est√°n las RIM; en el eje Y estan para cada a√±o los quinquios y de eso es un gr√°fico por SS.
```

```{r}
## paleta de colores

c25 <- c(
  "blue1", "brown", "gray70", "green4", "#6A3D9A", "gold1", "skyblue2",  "steelblue4", "palegreen2", "#CAB2D6", "deeppink1", "#FDBF6F", "#E31A1C", "black", "maroon", "orchid1", "dodgerblue2", "#FB9A99", "#FF7F00", "darkturquoise", "green1", "yellow4", "yellow3", "darkorange4", "khaki2" )
```

```{r  fig.width=40 ,fig.height= 40}
## Gr√°fico. Debe ser como un spaghetti plot para comparar, sino tabla como material suplementario
plot2$A√ëO <- as.factor(plot2$A√ëO)

rim.plot2 <- ggplot(plot2, # df de donde se obtienen los datos
                    
       aes(x = A√ëO,                      # eje x : variable A√ëO
           y = RIM.2,                    # eje y: varibale tasa
           fill = QUINQUENIO)) +         # color segun Servicio_salud
  
  geom_bar(stat = "identity",            # barra horizontal
           position = position_dodge(width = 0.95)) +   # L√≠nea de incidencia por a√±o
                          
  
  facet_wrap(~ Servicio_salud,           ## Un gr√°fico por servicio de salud
             scales = "fixed",           ## Valores del eje y varien segun los valores de la variable
             ncol = 1) +                 ## el wrap ordenado en una sola columna
  
  scale_fill_manual(values = c25) +      ## paleta de colores
  
  theme_minimal() +
  
  theme(legend.position = "bottom",
        panel.grid.minor = element_blank(),
    
    # üëá Aqu√≠ el cambio de tama√±os
    plot.title = element_text(size = 30, face = "bold", hjust = 0.5), ## config del titulo
    axis.title.x = element_text(size = 25),              ## config titulo eje X
    axis.title.y = element_text(size = 25),              ## config titulo eje Y
    axis.text.x = element_text(size = 20),               ## config texto eje X
    axis.text.y = element_text(size = 20),               ## config texto eje Y
    strip.text = element_text(size = 25),                ## config t√≠tulos de facetas
    legend.text = element_text(size = 20),               ## config texto de la leyenda
    legend.title = element_text(size = 20, face = "bold") ## config titulo de la leyenda
  ) +  

  
  labs(title = "Raz√≥n Mortalidad /Incidencia de GC por quinquenios en Servicios de Salud", 
       x = "A√±o", 
       y = "RIM") +
 
   guides(
    fill = guide_legend(nrow = 2)           # Organizar la leyenda en 2 filas
  )
  
rim.plot2

# ggsave("rim_plot_2.jpeg",  rim.plot2,  width = 30,  height = 27, dpi = 300)

```

# 4. Estimaci√≥n incidencia, mediante la RIM

```{r}
## Corresponde modelar la RIM para el CG con modelo mixto poisson lineal con intercepto aleatorio para los SS

## modelo poisson (o bin neg)

## ln(casos nuevos) = sexo + edad categ + ln(def) ; en los SS de los RPC respectivos.

## con esto, se estima la RIM del resto de SS con las estimaciones de par√°metros del modelo (usando predict).

## hay que reagrupar la variable edad de defuncion, por mediana, tercil o cuartil, hasta que en ninguna categoria queden defunciones = 0.

 #rim <- rim %>%
  #mutate(Defunciones_1 = if_else(is.na(Defunciones), 1, Defunciones),
   #      Defunciones_01 = if_else(is.na(Defunciones), 0.00001, Defunciones))
```

## Corrleaci√≥n

```{r}
# estructura de covarinza de incidencias.
## pasas inc_matriz a long
long_inc_matriz <- inc_matriz %>%
    pivot_longer(
    cols = -Servicio_salud,     
    names_to = "A√ëO",            
    values_to = "incidencias") %>%
  mutate(A√ëO = as.numeric(A√ëO))

options(contrasts = c(factor = "contr.SAS", ordered = "contr.ply"))

library(nlme)
m <- nlme::gls(
  model = incidencias ~ A√ëO,
  correlation = corAR1(form = ~A√ëO | Servicio_salud) , ## correlacion 1, respecto a cada a√±o.
  data = long_inc_matriz,
  weights = varIdent(form = ~1| A√ëO),
  na.action = na.omit ,
)
m

# Phi = 0.93: alta autocorrelaci√≥n entre a√±os dentro de cada Servicio_salud .
# VarIdent: las desviaciones est√°ndar por a√±o var√≠an bastante (valores muy peque√±os para 1998‚Äì2002 y grandes en a√±os recientes por pocos datos. hay heterocedasticidad.

## para el m2 se puede considerar incroporar la estructura de correlaci√≥n, AR(1). y manejar la heterocedasticidad por a√±o con dispersi√≥n estructurada, dispformula = ~ A√ëO
```

## 4.1. Adm de datos para ajuste del modelo

```{r}
## Datos para ajuste de modelos

## a los datos de defunciones (que est√°n m√°s completos) deben a√±ad√≠rsele los datos de incidencias
datos.modelo <- left_join(defunciones,    
                          incidencias,
                          by = c("Servicio_salud",
                               "SEXO",
                               "A√ëO",
                               "QUINQUENIO"))

datos.modelo$SEXO <- factor(datos.modelo$SEXO)                       ## verif formato de variables
datos.modelo$QUINQUENIO <- factor(datos.modelo$QUINQUENIO)           ## verif formato de variables
datos.modelo$Servicio_salud <- factor(datos.modelo$Servicio_salud)   ## verif formato de variables


## en las estimaciones del MINSAL parten del tramo etario 15-19 (incluyendo al CG).

## modelo lineal mixto poisson a partir de los datos de incidencia del registro poblacional (menos completa, se realiza en ciertas zonas geogr√°ficas) de cancer; los datos de defunciones de a√±adieron de la base de defunciones (m√°s completa, nivel pa√≠s).

## incidencias ~ intercepto aleatorio servivio salud + ln(defunciones) + sexo + quinquenio

## a partir de este modelo estimo los coeficientes del modelo y obtengo las incidencias esperadas al reemplazar el dato de defunci√≥n que si tengo para los servicios de salud donde no tengo informacion de incidencia.

## neceisto tener 2 df a partir de rim. el df que tiene la info completa (inc + def) y el def que no tiene la incidenia, pero si el resto de variables (defunciones, sexo y quinquenio).

## tiene que ser esta estructura left_join(def, inc, by=""), porque donde tengo m√°s es en defunciones, los SS y def, con los cuales quiero estimar la incidencia de los SS que no tienen datos de incidencia.

## es necesario a√±adir la variable REGION para el ajuste del modelo, para incidencias y defunciones.
```

## 4.2. Ajuste del modelo

### 4.2.1 Datos modelo

```{r}
## Datos para la estimaci√≥n de los coeficientes del modelo mixto poisson.
datos.m1 <- datos.modelo %>%
  
  ## filtar niveles  de quinquenio que no est√°n
  filter(!(QUINQUENIO %in% c("10-14", "0-4", "15-19"))) %>%
  
  ## sacar niveles
  droplevels() %>%                    
  
  ## saber de que datos se dispondr√° para obtener los coeficientes del modelo.
  mutate(incidencia_disponible = !is.na(incidencias)) %>% 

  ## filtar dejando los que no son NA en incidencias
  filter(!is.na(incidencias)) 

## este df esta completo (datos.m1) y tiene los datos con los que se realizar√° la estimaci√≥n de incidencia para los datos donde solo hay defunciones.
```

############################################ 

# loop de prueba

```{r}
## datos sin a√±o
datos.m1 <- datos.m1 %>%
  dplyr::select(Servicio_salud, SEXO, QUINQUENIO, Defunciones, incidencias) %>%
  group_by(Servicio_salud, SEXO, QUINQUENIO) %>%
  summarise(incidencias = sum(incidencias),
            Defunciones = sum(Defunciones))


### modelo
## con glmTBm
m2_2 <- glmmTMB::glmmTMB(
  formula = incidencias ~ offset(log(Defunciones)) + SEXO + QUINQUENIO +   ## variables modelo
                  (1 | Servicio_salud),                                    ## intercapto aleatorio
    data = datos.m1,                                                       ## datos
    family = poisson(link = "log"),
  na.action = na.omit)

m2_2

## verif modelo
datos.verif_2_2 <- datos.m1 %>%
  
  ## es importante a√±adir este comando ya que los dos df (de ajuste del modelo y datos para su verificaci√≥n) deben tener la misma cantidad de filas.
  filter(!is.na(Defunciones))

## Estimaci√≥n media condicional. considera los efectos aleatorios y el BULP
verif_2_2 <- predict(m2_2, 
                   newdata = datos.verif_2_2, 
                   type = "link", 
                   se.fit = TRUE,
                  allow.new.levels = T)

datos.verif_2_2$predicho <- verif_2_2$fit 
datos.verif_2_2$se <- verif_2_2$se.fit
## creaci√≥n de IC 95%. V√°lido pues la inferencia es sobre el valor esperado, lambda, que es el EMV, que distribuye aprox normal.
datos.verif_2_2$inf_link <- datos.verif_2_2$predicho - 1.96 * datos.verif_2_2$se
datos.verif_2_2$sup_link <- datos.verif_2_2$predicho + 1.96 * datos.verif_2_2$se

datos.verif_2_2 <- datos.verif_2_2 %>%
  mutate(
    predicho = exp(predicho),
    se = exp(se),
    inf_link = exp(inf_link),
    sup_link = exp(sup_link),
    cobertura_ic = ifelse(incidencias >= inf_link & incidencias <= sup_link, 1, 0))

## proporcion de cobertura
( prop  = sum(datos.verif_2_2$cobertura_ic) / length(datos.verif_2_2$cobertura_ic) * 100)
## en 77% de ocasiones el ic incluye la incidencia observada.

performance::check_model(m2_2)


## predicciones modelo:
datos.pred_2_2 <- datos.m1 %>%
  filter(!(QUINQUENIO %in% c("10-14", "0-4", "15-19"))) %>%
  
  droplevels() %>%                    
  
  filter(!is.na(Defunciones)) %>%
  
  dplyr::select(-incidencias)

## asegurar que queden los mismos niveles entre datos.modelo y datos.pred
datos.pred_2_2$SEXO <- factor(datos.pred_2_2$SEXO, levels = levels(datos.m1$SEXO))
datos.pred_2_2$QUINQUENIO <- factor(datos.pred_2_2$QUINQUENIO, levels = levels(datos.m1$QUINQUENIO))
datos.pred_2_2$Servicio_salud <- factor(datos.pred_2_2$Servicio_salud, levels = levels(datos.m1$Servicio_salud))

## prediccion de incidencias con el df datos.pred utilizando los coeficientes del modelo ajustado m1
predicciones_2_2 <- predict(m2_2,                       ## modelo
                        newdata = datos.pred_2_2,     ## df con nuevos datos (las predicciones)
                        type = "response",        ## la variables respuesta
                        allow.new.levels = T,     ## esto permite predecir para servicios no vistos
                        se.fit = T)     

## a√±adir varible predicciones al df de datos.pred.
datos.pred_2_2$pred_incidencias <- predicciones_2_2$fit 
datos.pred_2_2$se_pred_incidencias <- predicciones_2_2$se.fit



## unir df datos m1 + datos.verif + datos pred.
datos.m1 <- datos.m1 %>%
  mutate(
    tipo = case_when(
      is.numeric(incidencias) ~ "Observado",
      TRUE ~ NA_character_) )

datos.pred_2_2 <- datos.pred_2_2 %>%
    mutate(tipo = case_when(is.numeric(pred_incidencias) ~ "Predicho", TRUE ~ NA_character_)) %>%
    rename(incidencias= pred_incidencias) %>%
    dplyr::select(-se_pred_incidencias)

datos.completos_2_2 <- rbind(datos.m1, datos.pred_2_2) %>%
  unique()

save(datos.completos_2_2, file = "datos.oe2_2_2.RData")

```

###################################################################### 

### 4.2.2. Modelo Poisson

```{r}
## con glmTBm
m2 <- glmmTMB::glmmTMB(
  formula = incidencias ~ offset(log(Defunciones)) + SEXO + QUINQUENIO +   ## variables modelo
                  (1 | Servicio_salud),                                    ## intercapto aleatorio
    data = datos.m1,                                                       ## datos
    family = poisson(link = "log"),
  na.action = na.omit)

m2
## desviaci√≥n estandar del intercepto aleatorio = 0.262
exp_coef <- exp(fixef(m2)$cond)     # $cond estrae la parte condicional
exp_coef
## uso de TBM

## Especificaci√≥n del modelo: se define la funci√≥n objetivo (verosimilitud o log-verosimilitud) en C++ (o usando plantillas ya hechas). Compilas el modelo: TMB lo transforma en c√≥digo r√°pido que R puede llamar. Optimizaci√≥n: se estima el modelo (p.ej., efectos fijos, varianzas de los aleatorios) mediante m√°xima verosimilitud. Laplace Approximation: integra los efectos aleatorios para obtener la verosimilitud marginal. Inference: usa la matriz de informaci√≥n para obtener errores est√°ndar y hacer inferencia.

```

```{r}
## revisar paquete dist, o con errores cuadr√°tico medio y/o absoluto.
```

## 4.3. Bondad del ajuste del modelo

```{r}
## verificaci√≥n del modelo, usando los datos con los que se estimaron los coeficientes (ver los errores), excepto la incidencia, se quiere predecir para comparar entre lo estimado por el modelo y lo observado.

datos.verif <- datos.m1 %>%
  
  ## dejar todas las columnas menos incidencia_disponible
  dplyr::select(Servicio_salud, SEXO, A√ëO, QUINQUENIO, Defunciones, incidencias) %>%
  
  ## es importante a√±adir este comando ya que los dos df (de ajuste del modelo y datos para su verificaci√≥n) deben tener la misma cantidad de filas.
  filter(!is.na(Defunciones))
```

```{r}
## Estimaci√≥n media condicional. considera los efectos aleatorios y el BULP
verif <- predict(m2, 
                   newdata = datos.verif, 
                   type = "link", 
                   se.fit = TRUE,
                   allow.new.levels = T)
## interpretaci√≥n: Para este servicio espec√≠fico, con su intercepto aleatorio, el valor esperado es X ¬± se

## estimaci√≥n media marginal. mediante metodo delta, consiera los efectos fijos
## marginaleffects::predictions(m2)
## interpretaci√≥n: Para un servicio promedio, el valor esperado es X ¬± se
```

```{r}
## a√±adir variable predicho (los valores estimados) al df de datos.pred, a partir de verificacion 
datos.verif$predicho <- verif$fit 
datos.verif$se <- verif$se.fit
## creaci√≥n de IC 95%. V√°lido pues la inferencia es sobre el valor esperado, lambda, que es el EMV, que distribuye aprox normal.
datos.verif$inf_link <- datos.verif$predicho - 1.96 * datos.verif$se
datos.verif$sup_link <- datos.verif$predicho + 1.96 * datos.verif$se
## revisar con margins los IC
```

```{r}
## Pasar a escala respuesta con exp.
datos.verif <- datos.verif %>%
  mutate(
    predicho = exp(predicho),
    se = exp(se),
    inf_link = exp(inf_link),
    sup_link = exp(sup_link),
    cobertura_ic = ifelse(incidencias >= inf_link & incidencias <= sup_link, 1, 0))

# Residuos
datos.verif<- datos.verif %>%
  mutate(residuos = residuals(m2, type = "response"),
         residuos.pearson = residuals(m2, type = "pearson"),
         residuos.est = residuos/se)

## cobertura al nivel del modelo.     
( prop  = sum(datos.verif$cobertura_ic) / length(datos.verif) )

## verificar las predicciones
## revisar f√≥rmula de intervalos para programar.
## con los intervalos a mano hago la suma y veo como quedan.
```

### 4.2.4. Errores del modelo

```{r}
## errores del modelo 
datos.verif %>%
  mutate(truth = incidencias,
         estimate = predicho) %>%
  metrics(truth = truth,             ## m√©tricas del modelo
          estimate = estimate)

## rmse: error cuadr√°tico medio
## rsq: r2
## mae: error medio absoluto


( mape <- mean(abs((datos.verif$incidencias - datos.verif$predicho) / datos.verif$incidencias)) * 100 )
## mape de 48%, al limite de lo aceptable.
```

### 4.2.5. Grafica del modelo ajustado

```{r}
ggplot(datos.verif, aes(x = predicho, y = incidencias)) +
  geom_point(alpha = 0.6, color = "blue") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "red") +
  labs(
    x = "Predicho por el modelo",
    y = "Observado",
    title = "Dispersi√≥n Observado vs. Predicho",
    subtitle = "L√≠nea roja = ajuste perfecto"
  ) +
  theme_minimal()
```

```{r fig.height= 25, fig.width= 20}
## Plot incidencias en el timepo
plot.res <- datos.verif %>%
  group_by(Servicio_salud, A√ëO) %>%
  summarise(
    incidencias = sum(incidencias),
    predicho = sum(predicho),
    .groups = "drop") %>%
  
  ##pasar a formato long para plotear
  pivot_longer(cols = c(incidencias, predicho), ## hacerlo long para plotear
               names_to = "Tipo",
               values_to = "Valor") %>%
   mutate(Tipo = recode(Tipo,
                       incidencias = "Observado",
                       predicho = "Predicho"))
```

```{r fig.height= 25, fig.width= 20}
plot.3<- ggplot(plot.res, 
                
## especificiaciones de las aesthetic del gr√°fico
                aes(x = A√ëO,           ## dejar en el eje X los a√±os
                     y = Valor,        ## en el eje Y van los valores (incidencias obs y predichas)
                     color = Tipo,     ## habr√° un color distinto por cada nivel de la varibale tipo
                     linetype = Tipo,  ## los tipo de l√≠nea ser√°n seg√∫n los niveles de la variable tipo
                     group = Tipo)) +  ## los valores a gr√°ficar se agrupar√°n segun la variable tipo

## especificaciones del grosor de cada l√≠nea  
  geom_line(size = 1.2) +

## hacer un facet con una columna donde el eje Y var√≠e en cada plot seg√∫nn los valores que toma para cada servicio
  facet_wrap(~ Servicio_salud, ncol = 1, scales = "free_y") +

##  Escalar el eje X seg√∫n los a√±os
  scale_x_continuous(breaks = unique(plot.res$A√ëO)) +

## etiquetas del: t√≠tulo, subt√≠tulo, eje X y eje Y; incando los colores y tipo de linea
  labs(title = "Incidencias observadas vs predichas",
       subtitle = "Por Servicio de Salud y A√±o",
       x = "A√±o",
       y = "Casos nuevos de c√°ncer g√°strico",
       color = "Casos nuevos",         ## t√≠tulo de la leyenda
       linetype = "Casos nuevos") +    ## lineas para cada
  
## tema del gr√°fico
  theme_minimal(base_size = 14) +

## especificaciones del tama√±o de letra
  theme(
    strip.text = element_text(size = 20),                 
    axis.text.x = element_text(size = 15, angle = 45, hjust = 1),
    axis.text.y = element_text(size=15),
    plot.title = element_text(size = 25, face = "bold"),
    plot.subtitle = element_text(size = 20),
    legend.text = element_text(size = 20),                 
    legend.title = element_text(size = 22, face = "bold"),
    axis.title = element_text(size = 20)
  )
plot.3
# ggsave("res_plot_3.jpeg",   plot.3, width = 20, height = 25, dpi = 300)
```

```{r}
## plot res con geom_ribbon. para esto es NECESARIO tener todo en columnas separadas, NO en long
plot.res2 <- datos.verif %>%
  group_by(Servicio_salud, A√ëO) %>%
  summarise(
    incidencias = sum(incidencias),
    predicho = sum(predicho),
    ic_sup = sum(sup_link),
    ic_inf = sum(inf_link),
    cobertura_ic = ifelse(incidencias >= ic_inf & incidencias <= ic_sup, 1, 0),
  .groups = "drop")

## cobertura IC al nivel de datos agrupados.     
( prop  = sum(plot.res2$cobertura_ic) / length(plot.res2) )
```

```{r fig.height= 25, fig.width= 20}
plot.3_5 <- ggplot(plot.res2, aes(x = A√ëO)) +
  
  # Banda de IC
  geom_ribbon(aes(ymin = ic_inf, 
                  ymax = ic_sup), 
              fill = "blue", alpha = 0.2) +
  
  # L√≠nea predicha
  geom_line(aes(y = predicho, 
                color = "Predicho", 
                linetype = "Predicho"), 
            size = 1.2) +
  
  # L√≠nea observada
  geom_line(aes(y = incidencias, 
                color = "Observado",
                linetype = "Observado"), 
            size = 1.2) +
  
  facet_wrap(~ Servicio_salud, ncol = 1, scales = "free_y") +
  scale_x_continuous(breaks = unique(plot.res2$A√ëO)) +
  labs(
    title = "Incidencias observadas vs predichas con intervalos de confianza",
    subtitle = "Por Servicio de Salud y A√±o",
    x = "A√±o",
    y = "Casos nuevos de c√°ncer g√°strico",
    color = "Casos nuevos",
    linetype = "Casos nuevos"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    strip.text = element_text(size = 20),
    axis.text.x = element_text(size = 15, angle = 45, hjust = 1),
    axis.text.y = element_text(size=15),
    plot.title = element_text(size = 25, face = "bold"),
    plot.subtitle = element_text(size = 20),
    legend.text = element_text(size = 20),
    legend.title = element_text(size = 22, face = "bold"),
    axis.title = element_text(size = 20)
  )
plot.3_5
## ggsave("res_plot_3_5.jpeg",   plot.3_5, width = 20, height = 25, dpi = 300)
```

## 4.4. Estimaci√≥n a partir de los datos de mortalidad.

```{r}
## prediccion de incidencias a partir del datos de mortalidad, con esta info de probar√° el modelo ajustado.
## hacer df con datos de SS, pero que no tienen el dato de incidencia de RPC.
datos.pred <- datos.modelo %>%
  
  ## filtar niveles  de quinquenio que no est√°n
  filter(!(QUINQUENIO %in% c("10-14", "0-4", "15-19"))) %>%
  
  ## sacar niveles
  droplevels() %>%                    
  
  ## son las filas donde quiero predecir a partir del modelo, es decir, donde no tengo informaci√≥n de incidencia, obtener solo a partir de las defunciones.
  filter(!is.na(Defunciones)) %>%
  
  ## sacar columna
  dplyr::select(-incidencias)

# datos.pred$incidencias = NA   

## asegurar que queden los mismos niveles entre datos.modelo y datos.pred
datos.pred$SEXO <- factor(datos.pred$SEXO, levels = levels(datos.m1$SEXO))
datos.pred$QUINQUENIO <- factor(datos.pred$QUINQUENIO, levels = levels(datos.m1$QUINQUENIO))
datos.pred$Servicio_salud <- factor(datos.pred$Servicio_salud, levels = levels(datos.m1$Servicio_salud))

## datos.pred y datos.m1 tienen la misma estructura de DF salvo en que el primero no tiene la variable incidencia
```

```{r}
## prediccion de incidencias con el df datos.pred utilizando los coeficientes del modelo ajustado m1
predicciones <- predict(m2,                       ## modelo
                        newdata = datos.pred,     ## df con nuevos datos (las predicciones)
                        type = "response",        ## la variables respuesta
                        allow.new.levels = T,     ## esto permite predecir para servicios no vistos
                        se.fit = T)     

## a√±adir varible predicciones al df de datos.pred.
datos.pred$pred_incidencias <- predicciones$fit 
datos.pred$se_pred_incidencias <- predicciones$se.fit
```

```{r}
## unir df datos m1 + datos.verif + datos pred.
datos.m1 <- datos.m1 %>%
  mutate(
    tipo = case_when(
      is.numeric(incidencias) ~ "Observado",
      TRUE ~ NA_character_) ) %>%
  dplyr::select(-incidencia_disponible)
```

```{r}
## este no es necesario
datos.verif <- datos.verif %>%
  pivot_longer(
    cols = c(incidencias, predicho), ## hacerlo long para plotear
               names_to = "tipo",
               values_to = "incidencias") %>%
   mutate(tipo = recode(tipo,
                       incidencias = "Observado",
                       predicho = "Predicho")) %>%
  dplyr::select(Servicio_salud, A√ëO, SEXO, QUINQUENIO, Defunciones, incidencias, tipo)
```

```{r}
datos.pred <- datos.pred %>%
    mutate(tipo = case_when(is.numeric(pred_incidencias) ~ "Predicho", TRUE ~ NA_character_)) %>%
    rename(incidencias= pred_incidencias) %>%
    dplyr::select(-se_pred_incidencias)
```

```{r}
datos.completos <- rbind(datos.m1, datos.verif, datos.pred) %>%
  unique()
## este df esta bien.
```

```{r eval=F}
save(datos.completos, file = "datos.oe2.RData")
```

```{r}
## Gr√°fico de incidencias
plot.final <- datos.completos %>%
  group_by(Servicio_salud, A√ëO, tipo) %>%
  summarise(incidencias = sum(incidencias))
```

```{r fig.height= 35, fig.width= 25}
plot.7 <- ggplot(plot.final, aes(x = A√ëO,
                                 y = incidencias,
                                 group = tipo,
                                 color = tipo,
                                 linetype = tipo))+
  
  geom_line(size = 1.2)+
  
  facet_wrap(~ Servicio_salud, ncol = 2, scales = "free_y") +
  
   scale_x_continuous(breaks = unique(plot.res$A√ëO)) +

## etiquetas del: t√≠tulo, subt√≠tulo, eje X y eje Y; incando los colores y tipo de linea
  labs(title = "Incidencias observadas vs predichas",
       subtitle = "Por Servicio de Salud y A√±o",
       x = "A√±o",
       y = "Casos nuevos de c√°ncer g√°strico",
       color = "Casos nuevos",         ## t√≠tulo de la leyenda
       linetype = "Casos nuevos") +    ## lineas para cada
  
## tema del gr√°fico
  theme_minimal(base_size = 14) +

## especificaciones del tama√±o de letra
  theme(
    strip.text = element_text(size = 20),                 
    axis.text.x = element_text(size = 15, angle = 45, hjust = 1),
    axis.text.y = element_text(size=15),
    plot.title = element_text(size = 25, face = "bold"),
    plot.subtitle = element_text(size = 20),
    legend.text = element_text(size = 20),                 
    legend.title = element_text(size = 22, face = "bold"),
   axis.title = element_text(size = 20)
  )
plot.7
# ggsave("plot7.jpeg", plot.7, width = 35, height = 25, dpi = 300)  
```

```{r}
## esperar a sandra para intervalos de predicci√≥n.
```

## 4.5. Diagn√≥sticos del modelo (Post-Hoc).

```{r}
## usar paquete dharma
   #Residuos (Pearson/Deviance)
   #Sobredispersi√≥n
   #seudo-R¬≤
   #DHARMa
```

```{r}
set.seed(1989)
sim <- simulateResiduals(m2, plot= T, n = 1000) ## el an√°lisis de los residuos indica que que existe alguna desviaci√≥n sistem√°tica entre el modleo y los datos, por alguna estructura no capturada; posiblemente: efecto no lineal del a√±o (incluri como un factor o spline); alguna cov que falta; un efecto de interaccion, o prob de especificaci√≥n.

# plotResiduals(sim, form = datos.m1$Servicio_salud)

## test de dispersi√≥n
testDispersion(sim) #no hay evidencia para suponer que hya sub o sobre dispersi√≥n, p-valor = 0.58

## test de uniformidad
testUniformity(sim)    ## no sigue una distribuci√≥n uniforme

## Exceso de ceros
testZeroInflation(sim) ## problema con los zero, se est√°n predicion mas de los hay. Este es mas bien un problema de la distribuci√≥n teorica Poisson, las imulaciones del modelo esperan mas zero de los que hay (no hay jaja)

## autocorrelaci√≥n
# testTemporalAutocorrelation(sim, time = datos.m1$A√ëO)

## al a√±adir el a√±o tener cuido en que no a√±adirlo como una covariable mas, sino que ver el efecto del a√±o por servicio
## revisar funcion simulate para las predicciones.

```

```{r fig.width=15}
mf<- model.frame(m2)
plotResiduals(sim, form = mf$Servicio_salud, main = "Residuos por Servicio de Salud")
## no ajustra bien por SS.
```

```{r}
performance::check_model(m2)
```

```{r}
## recomendaci√≥n:
## podr√≠a incluirse el factor tiempo en el modelom ns(A√ëO, df = 3)
## o permitir que la eondiente varie entre SS, (1+A√ëO|SS)
```

```{r}
# es problem√°ico en el contexto global de la tesis?
## notar que el prop√≥sito de este modelo (MLMG) no es capatar la tendencia temporal, sino obtener una estimaci√≥n basal de incidencias por SS-SEXO-Qinquenio. y las din√°micas de temporalidad (A√ëO) se manejan luego en los modelos de predicci√≥n. Ahora, si se incluyera el a√±o en este modelo (MLMG), se mezclar√≠a la parte estructural dadas por el grupo y las covariables con la tendencia temporal. Con el an√°lisis actual est√° separada la estructura respescto a la tendencia (OE3).
## En este sentido, con este modelo no se usca el mejor ajuste global, sino que una estrcutra que permitra estimar de manera consistente. En este sentido, no se afecta el objetivo pricnipal de este modelo.
## Respecto a este modelo,DHARMA indica que hay diferencias sistem√°ticas por SS. Es esperable porque el modelo es parsimonioso(quiza demasiado), y su objetivo es geenrar estimaciones consistentes y extrapolables.
```

```{r fig.width= 25, fig.height=15}
## gr√°fico de residuos.

plot4 <- ggplot(datos.verif , 
       aes(x = incidencias, y = residuos)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray40") +
  geom_point(alpha = 0.6, color = "steelblue") +
  facet_grid(SEXO ~ QUINQUENIO) +  # O puedes usar Servicio_salud ~ sexo, etc.
  labs(
    x = "Incidencia observada",
    y = "Residuos (observado - predicho)",
    title = "Residuos del modelo seg√∫n incidencia observada",
    subtitle = "Gr√°ficos por sexo y grupo etario"
  ) +
  theme_minimal(base_size = 14)+
   theme(
    strip.text = element_text(size = 20),                 
    axis.text.x = element_text(size = 15, angle = 45, hjust = 1),
    axis.text.y = element_text(size=15),
    plot.title = element_text(size = 25, face = "bold"),
    plot.subtitle = element_text(size = 20),
    axis.title = element_text(size = 20)
  )
plot4
```

```{r fig.width= 25, fig.height=15}
## gr√°fico de residuos estandarizados.

plot5 <- ggplot(datos.verif , 
       aes(x = incidencias, y = residuos.est)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray40") +
  geom_point(alpha = 0.6, color = "steelblue") +
  facet_grid(SEXO ~ QUINQUENIO) +  # O puedes usar Servicio_salud ~ sexo, etc.
  labs(
    x = "Incidencia observada",
    y = "Residuos estandarizados",
    title = "Residuos estandarizados del modelo seg√∫n incidencia observada",
    subtitle = "Gr√°ficos por sexo y grupo etario"
  ) +
  theme_minimal(base_size = 14)+
   theme(
    strip.text = element_text(size = 20),                 
    axis.text.x = element_text(size = 15, angle = 45, hjust = 1),
    axis.text.y = element_text(size=15),
    plot.title = element_text(size = 25, face = "bold"),
    plot.subtitle = element_text(size = 20),
    axis.title = element_text(size = 20)
  )
plot5
```

```{r fig.width= 25, fig.height=15}
plot6 <- ggplot(datos.verif , 
       aes(x = incidencias, y = residuos.pearson)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray40") +
  geom_point(alpha = 0.6, color = "steelblue") +
  facet_grid(SEXO ~ QUINQUENIO) +  # O puedes usar Servicio_salud ~ sexo, etc.
  labs(
    x = "Incidencia observada",
    y = "Residuos de Pearson",
    title = "Residuos de Pearson del modelo seg√∫n incidencia observada",
    subtitle = "Gr√°ficos por sexo y grupo etario"
  ) +
  theme_minimal(base_size = 14)+
   theme(
    strip.text = element_text(size = 20),                 
    axis.text.x = element_text(size = 15, angle = 45, hjust = 1),
    axis.text.y = element_text(size=15),
    plot.title = element_text(size = 25, face = "bold"),
    plot.subtitle = element_text(size = 20),
    axis.title = element_text(size = 20)
  )

plot6

# ggsave("res_plot_6.jpeg",   plot6, width = 25, height = 25, dpi = 300)
```

```{r fig.width= 25, fig.height=15}
## si bien se observa sobredispersi√≥n, no se observan sesgos en los residuos. HACER ALGO CON ESA SOBREDISPERSI√ìN.
## resumir el gr√°fico, con colores de puntos distintos para hombres y hombres y mujeres. entonces, sacar el facet.
```

```{r}
## revisar la varianza; o considerar un binomial negativo,
## ver linealidad de los residuos.
## ver si se puede explicar un termino cuadratico, ya que se supone una linea lisas, pero no se ve en los a√±os.
```
