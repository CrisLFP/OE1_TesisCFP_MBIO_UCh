---
title: "RPC"
author: "Cristian Flores Peñailillo"
format: html
editor: visual
---

```{r message=F}
## Ambiente de trabajo
gc()
setwd("~/Desktop/U_CHILE/MG_BIOESTADÍSTICA/TESIS/DATOS PÚBLICOS/REGISTRO POBALCIONAL DE CÁNCER")
```

```{r message=F}
## Librerias a utilizar
library(haven)
library(tidyverse)
library(readxl)
library(readr)
library(kableExtra)
library(scales)
library(webshot)
```

# 1. Adm de datos

```{r eval=F}
##carga del registro poblacional de cáncer
RPC <- read_sav("BBDD_RPC_1998-2019_ID.sav")
```

```{r}
#summary(RPC)
```

```{r eval=F}
##filtrado por cáncer de estómago
cg<- RPC %>%
  filter(`Nombre_Cancer` == "C16 Tumor maligno del estómago")
```

```{r eval= F}
niveles <- levels(as.factor(RPC$Nombre_Cancer))
niveles
```

```{r eval = F}
table(cg$Morfologia) #revisar
```

```{r eval=F}
table(cg$Comportamiento) #revisar
```

```{r eval=F}
table(cg$Base_diagnostico)
```

##Variable Servicio de Salud.

```{r warning = F, eval=F}
#añadir SS.

##carga de establecimientos de salud

Establecimientos_salud <- read_excel("Establecimientos DEIS MINSAL 24-06-2024.xlsx") #establecimientos de salud al 24_06_2024, DEIS.

```

```{r eval=F}
SS <- Establecimientos_salud %>%
  dplyr::select(`Código Dependencia Jerárquica (SEREMI / Servicio de Salud)`,
         `Nombre Dependencia Jerárquica (SEREMI / Servicio de Salud)`,
         `Pertenencia al SNSS`,
         `Código Región`,
         `Nombre Región`,
         `Código Comuna`, 
         `Nombre Comuna`)%>%
  mutate(
    `Nombre Dependencia Jerárquica (SEREMI / Servicio de Salud)` = as.factor(`Nombre Dependencia Jerárquica (SEREMI / Servicio de Salud)`),
    `Pertenencia al SNSS` = as.factor(`Pertenencia al SNSS`), 
    `Nombre Región` = as.factor(`Nombre Región`), 
    `Nombre Comuna` = as.factor(`Nombre Comuna`),
    `Código Región` = as.numeric(`Código Región`),
    `regCom` = as.numeric(`Código Comuna`)
    )%>% #ahora filtar por servicion de salud
 filter(grepl("servicio", `Nombre Dependencia Jerárquica (SEREMI / Servicio de Salud)`, ignore.case = TRUE)) %>%#ahora hay que eliminar duplicados
  distinct(`regCom`,
           .keep_all = T) # Eliminar duplicados

#ahora la base de datos del SS está bien hecha

#ServSalud <- write_csv(SS, "ServSalud.csv")

#eliminrar varibles que no uso

```

```{r eval=F}
master_base <- inner_join(RPC, SS, by = "regCom")
```

```{r eval = F}
## código ya corrido. Si se realizan modificaciones en los chunk precedentes volver a ejecutar para modificar el documento .csv que se usa en el trabajo.
#csv.master_base <- write_csv(master_base, "RCP_con_SS.csv")
```

# 2. Estado de registros

## 2.1. RPC y servicios de salud

```{r message=F}

## base de datos de RPC con la variable de Servicio de Salud
RPC <- read_csv("RCP_con_SS.csv")

## Base de datos con el listado de Servicios de Salud y comunas del país.
ServSalud <- read_csv("ServSalud.csv")


## Adm de las bases de datos

### Formato a la fecha de nacimiento. Este formato especial es debido a que el archivo de origen el RPC es SPSS.
RPC$Fecnac <- as.Date(RPC$Fecnac, origin = "1899-12-30")

### ServSalud
ServSalud<- ServSalud %>%
  ## renombrar variables
  rename(CODIGO_COMUNA = regCom,
         Servicio_salud = `Nombre Dependencia Jerárquica (SEREMI / Servicio de Salud)`) %>%
  ## selección de variables a usar
  dplyr::select(Servicio_salud, CODIGO_COMUNA, `Nombre Comuna`)

### RPC
RPC <- RPC %>%
  
  ## selección de variables a utilizar en RPC
  dplyr::select(
    id_persona, RPC, regCom, Sexo, Edad, Quinquenios_edad,, Grupo_edad_1, Fecnac, Fecdiag, Año_diag, CIE10, Nombre_Cancer, Morfologia, Comportamiento, Base_diagnostico, VM, fecha_defuncion_act2020, Causa_defuncion, `Nombre Dependencia Jerárquica (SEREMI / Servicio de Salud)`, `Código Región`, `Nombre Región`, `Código Comuna`, `Nombre Comuna` )   %>%
  
  ## renombrar variables
  rename(
    codigo_region = `Código Región`,
    region = `Nombre Región`,
    codigo_comuna = `Código Comuna`,
    comuna = `Nombre Comuna`,
    Servicio_salud = `Nombre Dependencia Jerárquica (SEREMI / Servicio de Salud)` )   %>%
   
  ## modificación del formato variables
  mutate(
    Sexo = as.factor(Sexo),
    Quinquenios_edad = as.factor(Quinquenios_edad),
    Año_diag = as.numeric(Año_diag),
    CIE10 = as.factor(CIE10),
    Nombre_Cancer = as.factor(Nombre_Cancer),
    Morfologia = as.factor(Morfologia),
    Comportamiento = as.factor(Comportamiento),
    Servicio_salud = as.factor(Servicio_salud),
    codigo_region = as.numeric(codigo_region),
    region = as.factor(region),
    codigo_comuna = as.numeric(codigo_comuna),
    comuna = as.factor(comuna) )   %>%
  
  ## filtar por código CIE10 = a C169 correspondiente al cáncer gástrico
  filter(CIE10 == "C169")
```

## 2.2. Proyecciones poblacionales

```{r message=F}
## Carga de proyecciones poblacionales por comuna.
POBLACIONES_COMUNA <- read_csv("~/Desktop/U_CHILE/MG_BIOESTADÍSTICA/TESIS/DATOS PÚBLICOS/PROYECCIONES_POBLACIONALES/PROYECCION_COMUNA.csv")
```

```{r}
## Poblacion de cada SS

POBLACIONES_COMUNA <- POBLACIONES_COMUNA %>%
  
## variable que contiene el nombre comun del código de comuna en este script.
  mutate(CODIGO_COMUNA = Comuna) %>%
  
  ## Descartar columnas que no se usarán
  dplyr::select(-starts_with("Poblacion 202")) %>%
  dplyr::select(-starts_with("Poblacion 203"))

## añadir variable SS
POBLACIONES_COMUNA <- inner_join(POBLACIONES_COMUNA, ServSalud, by = "CODIGO_COMUNA") 
```

```{r}
## poblaciones por comuna, ex P_C
pob.comuna <- POBLACIONES_COMUNA %>%
  
  ## nota, se dejó CÓDIGO COMUNA Y Comuna, porque se usarán mas adelante en 5.2.
  dplyr::select(-`Nombre Comuna`) %>%
  
  ## agrupar según servicio de salud
  group_by(Servicio_salud) %>%
  
  ## Resumir información en la suma de las columnas
  summarise(across(starts_with("Poblacion"), sum)) %>%
  
  ## Dar formato long al df
  pivot_longer(
    #columnas a pasar a formato largo
    cols = starts_with("Poblacion"), # aquellas columnas que empiezan con población
    #nueva columna creada a partir de cols
    names_to = "AÑO",
    #nombre de la columa a crear a partir de los datos de las celdas
    values_to = "POBLACION" ) %>%
  
  ## La variable año remover el string "Poblacion" y dejando solo el año en formato numeric
  mutate(AÑO = as.numeric(str_remove(AÑO, "Poblacion "))) 
```

# 3. Completitud RPC

## 3.1. Completitud respecto a comunas por RPC

```{r}
## Para esta parte del análisis se verificará la completitud por SS de los distintos RPC en el tiempo. Esto quiere decir que se revisará cuantas comunas de un determinado SS están presentes en el RPC. Dado que conocemos el numero total de comunas pretenecientes a un RPC los resutlados serán expresados en porcentajes.

## Paso 1: creación de un nuevo df donde de manjeran las comunas, códigos de comuna y años, presentes en la base del RPC

ss_rpc <- RPC %>%
  
  ## selección de variables
  dplyr::select(Año_diag, codigo_comuna, comuna) %>%
  
  ## renombrar la variable codigo_comuna a CODIGO_COMUNA. Esta última es el nombre que tiene la variable en el df de ServSalud, con el cual se cotejará la completitud.
  rename(CODIGO_COMUNA = codigo_comuna) %>%
  
  #eliminar duplicados
  distinct()


## Creación del objteco completitud, que viene a ser la union entre ServSalud (que contiene el total de comunas en cada SS) y las comunas presents en el RPC. El enlace es a través de la variable CODIGO_COMUNA
completitud <- left_join(ServSalud, ss_rpc, by = "CODIGO_COMUNA")

## Creación de la variable binaria "presenta" en completitud1 la cual de genera como un ifelse para cuando hay un valor NA en la variable comuna de completitud 1 añade un 0 y un 1 en otro caso. De esta forma se calculará la proporcion
completitud$presenta <- ifelse(is.na(completitud$comuna), 0, 1) ## añadir 0 cuando la comuna no este presente y 1 cuando si lo este


## Obtención el total de comunas únicas por Servicio de Salud. Para laos 29 SS tengo cuantas comunas abarca
total_comunas_por_SS <- ServSalud %>%
  
  ## agrupar en el df ServSalud por la variable Servicio_salud
  group_by(Servicio_salud) %>%
  
  ## resumir el total de comunas contando los valores unicos con n_distinct en la variable "Nombre Comuna
  summarise(total_comunas = n_distinct(`Nombre Comuna`, 
                                       na.rm = TRUE)) %>%
  
  ## desagrupar el resultado, en caso de que se quieran hacer análisis posteriores.
  ungroup()


# obtención del número de comunas presentes en cada año (del RPC) por Servicio de Salud
comunas_por_año <- completitud %>%
  
  ## Consideramos solo comunas presentes
  filter(!is.na(comuna)) %>%  
  
  ## Agrupar por año y servicio de salud
  group_by(Año_diag, Servicio_salud) %>%
  
  ## contar las comunas unicas presentes
  summarise(presenta = n_distinct(comuna)) %>%
  
  ## desagrupar
  ungroup()


# Calculo el porcentaje de comunas presentes por año en cada Servicio de Salud

comunas_por_año <- comunas_por_año %>%
  ## a las comunas por año les añado las columnas coincidentes con el df se total de comunas por SS, cuando coinciden en la variable Servicio_salud
  left_join(total_comunas_por_SS, by = "Servicio_salud") %>%
  
  ## creación de la variable de porcentaje de cobertura.
  mutate(porcentaje = round((presenta / total_comunas) * 100,2) )
```

```{r fig.width=10, fig.height=8}
## Graficar la completitud de los RPC

## se hará un gráfico de facet_grid donde en el eje y estarán los porcentajes de completitud, en el eje x los años, y en cada fila del grid uno de los SS presentes en el RPC

## figura completitud.
completitud.plot <- ggplot(comunas_por_año,     ## df de donde se obtienen los datos
             
                               
      ## aestheticas del gráfico
       aes(x = factor(Año_diag),                ## eje x: variable factor Año_diag
           y = porcentaje,                      ## eje y: variable porcentaje
           fill = factor(Año_diag))) +          ## relleno se dará color según el año
  
  
      ## tipo de gráfico: geom_bar (gráfico de barras)
  geom_bar(stat = "identity",                   ## indicación que par usar valores proporcionados en ves de calcularlos para la columna Y (yo ya estyo dándole los porcentajes); su fuera stat= "count" (por default), contaria las ocurrencias en cada categoria 
           position = "dodge") +                ## position = "dodge", coloca las barrar una al lado de la otra en lugar de apilarlas cuando hay variaas categorisas en el eje x
  
       ## serie de facetas a graficar 
  facet_wrap(~ Servicio_salud,                  ## La figura final quedara con tantas facetas como SS existan  
             scales = "fixed",                  ## todos las facetas compartirar el mismo rango para los ejes x e y.
             ncol = 1) +                        ## Todas las facetas de organizaran en una sola columna. En este caso como las facetas son de SS, la columna será solo de servicios de salud.
  
  
      ## aplicaciónde una tima limpio, sin grises y reduciendo líneas innecesarias.
  theme_minimal() +
  
  
      ## dominio de valores que puede tomar el eje y
  ylim(0, 100) + 
  
  
      ## etiquetas del gráficos
  labs(title = "Porcentaje de comunas presentes por SS en el RPC, en cada año",    ## título del gráfico
       x = "Año",                                                        ## título eje x
       y = "Porcentaje de completitud (comunas)"    )      +            ## título eje y
  
   theme(legend.position = "none")  ## quitar la leyenda
                                                      

completitud.plot
```

```{r eval = F}
## exportar figura NO CORRER OTRA VEZ ESTE CHUNK
 ggsave("completitud.jpeg", 
  completitud.plot, ## formato de imagen, cambiar desde .png a .jpeg
  width = 11, 
  height = 7, 
  dpi = 300)
```

## 3.2. Cobertura respecto a población del SS en el RPC

```{r}

## a partir de las poblaciones por comunas, obtener un df donde esten las poblaciones de las comunas presentes en el RPC para cada año.

  ## tener en un df long
pob.cobertura <- POBLACIONES_COMUNA %>%
  
  ## nota, se dejó CÓDIGO COMUNA Y Comuna, porque se usarán mas adelante en 5.2.
  dplyr::select(-`Nombre Comuna`) %>%
  
  ## agrupar según servicio de salud
  group_by(CODIGO_COMUNA) %>%
  
  ## Resumir información en la suma de las columnas
  summarise(across(starts_with("Poblacion"), sum)) %>%
  
  ## Dar formato long al df
  pivot_longer(
    #columnas a pasar a formato largo
    cols = starts_with("Poblacion"), # aquellas columnas que empiezan con población
    #nueva columna creada a partir de cols
    names_to = "AÑO",
    #nombre de la columa a crear a partir de los datos de las celdas
    values_to = "POBLACION" ) %>%
  
  ## La variable año remover el string "Poblacion" y dejando solo el año en formato numeric
  mutate(AÑO = as.numeric(str_remove(AÑO, "Poblacion "))) 



### Comunas presentes en cada año por Servicio de Salud
comunas_por_año_2 <- completitud %>%
  
  ## Consideramos solo comunas presentes
  filter(!is.na(comuna)) %>%  
  
  ## Agrupar por año y servicio de salud
  group_by(Año_diag, CODIGO_COMUNA) %>%
  
  rename(AÑO = Año_diag) %>%
  
  dplyr::select(-`Nombre Comuna`, -presenta)


### poblacion por año en los SS del RPC
 
 ## unir df de comunas por año y la pob.cobertura
comunas_año_SS <- left_join(comunas_por_año_2, pob.cobertura , by = c("CODIGO_COMUNA", "AÑO"))


  ## calcular la poblacion por SS en cada año según las comunas presenten en el RPC
comunas_año_SS <- comunas_año_SS %>%
  
  group_by(Servicio_salud, AÑO) %>%
  
  summarise(POBLACION_RPC = sum(POBLACION))


 ## unir las comunas de cada SS con las poblaciones por comuna
completitud2 <- left_join(comunas_año_SS, pob.comuna, by = c("Servicio_salud", "AÑO"))

 ## renombrar variables 
completitud2 <- completitud2 %>%
  
  rename(Año_diag = AÑO)

 ## unir las poblaciones de de completitud2 con las comunas por año
completitud2 <- left_join(completitud2, comunas_por_año, by = c("Servicio_salud", "Año_diag"))

completitud2$cobertura <- round((completitud2$POBLACION_RPC/completitud2$POBLACION)*100,2)


## rodenar las columnas del DF
orden <- c(1, 2, 5, 6, 7, 3, 4, 8)
completitud2 <- completitud2[,orden]
```

```{r}
## Exportar resultados en tabla

tabla_coberturas_RPC <- kable(completitud2) %>%
## Estilo de la tabla  
  kable_styling(
    bootstrap_options = "striped") %>%
## añadido de título
  add_header_above(c("Porcentaje de comunas presentes y poblacion cubierta por SS en el RPC, en cada año" = 8)) %>%
## añadido de pie de página
  add_footnote(c("Tabla obtenida cruzando la información del Registro Poblaiconal del Cancer (Epidemiología, MINSAL) y de Establecimientos de Salud (DEIS, MINSAL)"), 
               notation = "number")


tabla_coberturas_RPC

```

```{r eval = F}
## Exportar datos completitud

save_kable(x=tabla_coberturas_RPC, 
           file="tabla_coberturas_RPC.jpeg")

write_csv(completitud2,
          "datos_coberturas_RPC.csv")

```

```{r fig.width=10, fig.height=8}
cobertura.plot <- ggplot(completitud2, # df de donde se obtienen los datos
             
                               
      ## aestheticas del gráfico
       aes(x = factor(Año_diag),                ## eje x: variable factor Año_diag
           y = cobertura,                      ## eje y: variable porcentaje
           fill = factor(Año_diag))) +          ## relleno se dará color según el año
  
  
      ## tipo de gráfico: geom_bar (gráfico de barras)
  geom_bar(stat = "identity",                   ## indicación que par usar valores proporcionados en ves de calcularlos para la columna Y (yo ya estyo dándole los porcentajes); su fuera stat= "count" (por default), contaria las ocurrencias en cada categoria 
           position = "dodge") +                ## position = "dodge", coloca las barrar una al lado de la otra en lugar de apilarlas cuando hay variaas categorisas en el eje x
  
       ## serie de facetas a graficar 
  facet_wrap(~ Servicio_salud,                  ## La figura final quedara con tantas facetas como SS existan  
             scales = "fixed",                  ## todos las facetas compartirar el mismo rango para los ejes x e y.
             ncol = 1) +                        ## Todas las facetas de organizaran en una sola columna. En este caso como las facetas son de SS, la columna será solo de servicios de salud.
  
  
      ## aplicaciónde una tima limpio, sin grises y reduciendo líneas innecesarias.
  theme_minimal() +
  
  
      ## dominio de valores que puede tomar el eje y
  ylim(0, 100) + 
  
  
      ## etiquetas del gráficos
  labs(title = "Porcentaje de población abarcada por SS en el RPC, en cada año",    ## título del gráfico
       x = "Año",                                                                   ## título eje x
       y = "Porcentaje de cobertura (personas)")     +                              ## título eje y
   
  theme(legend.position = "none")  ## quitar la leyenda
                                                       

cobertura.plot
```

```{r eval = F}
## exportar figura NO CORRER OTRA VEZ ESTE CHUNK
ggsave("cobertura.jpeg", 
  cobertura.plot, 
  width = 11, 
  height = 7, 
  dpi = 300)
```

## 3.3. Coberturas País

```{r}
## la idea de este gráfico es poner las coberturas país de los RPCs para cada año, con el respectivo numero de RPCs por año.
## sería un df: año, pob pais, pob RPc, numero RPC


## POBALCION
pob.pais <- pob.cobertura %>%
  group_by(AÑO) %>%
  summarise(POBLACION = sum(POBLACION, na.rm = TRUE))

pob.rpc <- comunas_año_SS %>%
  group_by(AÑO) %>%
    summarise(POBLACION_RPC = sum(POBLACION_RPC, na.rm = TRUE))

pob.pais <- left_join(pob.pais, pob.rpc, by = "AÑO") %>%
  mutate(PROPORCION = POBLACION_RPC / POBLACION,
         PORCENTAJE = PROPORCION * 100)

## COMUNAS
comunas.pais <- comunas_por_año %>%
  mutate(AÑO = Año_diag) %>%
  group_by(AÑO) %>%
  summarise(COMUNAS_RPC = sum(presenta, na.rm = TRUE),
            TOTAL_COMUNA = 345)
 

pob.pais <- left_join(pob.pais, comunas.pais, by = "AÑO") %>%
  mutate(PROPORCION_COMUNA = COMUNAS_RPC / TOTAL_COMUNA,
         PORCENTAJE_COMUNA = PROPORCION_COMUNA * 100)

```

```{r fig.height=5, fig.width=8}
cobertura.pais <- ggplot(pob.pais, aes(x = AÑO)) +
  # Área bajo la curva (cobertura poblacional)
  geom_area(aes(y = PROPORCION * 100), fill = "steelblue", alpha = 0.3) +

  # Línea principal
  geom_line(aes(y = PROPORCION * 100), color = "maroon", size = 1.2) +
  geom_point(aes(y = PROPORCION * 100), color = "maroon", size = 2) +

  # Barras: % de comunas con registro
  geom_col(aes(y = (COMUNAS_RPC / 345) * 100), 
           fill = "black", alpha = 0.5, width = 0.1) +

  # Etiquetas de número real de comunas sobre cada barra
  geom_text(
    aes(
      y = (COMUNAS_RPC / 345) * 100 + 7,  # un poco encima de la barra
      label = COMUNAS_RPC
    ),
    color = "black", size = 3.5
  ) +

  # Escala Y como porcentaje (0 a 100%)
  scale_y_continuous(
    name = " Porcentaje de Cobertura",
    limits = c(0, 100),
    breaks = seq(0, 100, 10)
  ) +
  
  scale_x_continuous(breaks = pob.pais$AÑO) +
  labs(
    x = "Año",
    title = "Porcentaje de Cobertura poblacional y comunal de RPCs, en el tiempo",
    caption = "Número comunas indicado sobre cada barra (máx: 345)"
  ) +
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 

cobertura.pais
```

```{r eval=F}
# Exportar figura. NO CORRER OTRA VEZ ESTE CHUNK
ggsave(
  filename = "cobertura.pais.jpeg",
  plot = cobertura.pais,
  width = 8, 
  height = 5, 
  dpi = 300)
```

```{r}
## tabla a exportar
tabla_coberturas_pais <- kable(pob.pais) %>%
## Estilo de la tabla  
  kable_styling(
    bootstrap_options = "striped") %>%
## añadido de título
  add_header_above(c("Coberturas poblacionales y comunales de RPCs, en el tiempo" = 9)) %>%
## añadido de pie de página
  add_footnote(c("Tabla obtenida cruzando la información del Registro Poblacional del Cancer (Epidemiología, MINSAL) y de Proyecciones Poblacionales (INE)"), 
               notation = "number")

tabla_coberturas_pais
```

```{r}
save_kable(x=tabla_coberturas_pais, 
           file="tabla_coberturas_pais.html")
```

# 4. Tasas de incidencia

### 4.1. Casos por año y SS

```{r}
## incidencias brutas por año y servicio de salud

inc.1 <- RPC %>%
  
  ## agrupar filas del RPC segun los niveles de las variables Año_diag y Servicio_salud
  group_by(Año_diag, Servicio_salud) %>%
  
  ## resumir en el número para las combinaciones generadas en el agrupamiento previo
  summarise(incidencias = n()) %>%
  
## pasar a wide
  pivot_wider(names_from = Servicio_salud,
              values_from = incidencias)


## hacer este df como tabla
tabla.inc.1 <- kable(inc.1) %>%
## Estilo de la tabla  
  kable_styling(
    bootstrap_options = "striped") %>%
## añadido de título
  add_header_above(c("Frecuencia absoluta de incidencias por CG en SS, 1998-2019" = 8)) %>%
## añadido de pie de página
  add_footnote(c("Tabla obtenida a partir del Registro Poblacional de Cancer publicada por departamendo de epidemiología del Minsal para el periodo 1998-2019"), 
               notation = "number")


## pasar a long (para trabajar más rápido)
inc.1.long <- inc.1 %>%
  ## P1 pasar a long
  pivot_longer(
    cols = -Año_diag,
    names_to = "Servicio_salud",
    values_to = "Incidencias") %>%
  arrange(Servicio_salud) %>%  # Ordenar por la segunda columna
  dplyr::select(Servicio_salud, everything())  %>%
  rename(AÑO = Año_diag)
```

### 4.2. Tasa de incidencias de GC por 100.000 habitantes en SS con RPC

```{r}

## hacer el inner_join por dos variables para asegurar que coincidan
tasa.inc <- inner_join(inc.1.long, pob.comuna, by = c("Servicio_salud", "AÑO"))

tasa.inc  <- tasa.inc %>%
  ## creación columna de tasas
  mutate(tasa =round( (Incidencias / POBLACION) * 100000,2) ) %>%
  na.omit()
  
```

### 4.3. Graficos incidencias

```{r fig.width=10, fig.height=15}
## plotear las incidencias de cada año en por SS (facet_frid / facet_wrap)

incidencias <- ggplot(tasa.inc,         # df de donde se obtienen los datos
       aes(x = AÑO,                     # eje x : variable AÑO
           y = tasa,                    # eje y: varibale tasa
           group = Servicio_salud,      # agrupar por la variables Servicio_salud
           color = Servicio_salud)) +   # color segun Servicio_salud
    
  geom_smooth(method = "lm",
              se = F,
              linetype = "solid",
              colour = "#8B8878",
              alpha = 0.05,
              linewidth = 0.6) +
  geom_line() +                         # Línea de incidencia por año
  geom_point() +                        # Puntos para visualizar las tasas
  facet_wrap(~ Servicio_salud, 
             scales = "free_y",
             ncol = 1) +  # Un gráfico por servicio de salud
  scale_x_continuous(breaks = unique(tasa.inc$AÑO)) +
  theme_minimal() +
  theme(legend.position = "none",   # Oculta la leyenda porque cada faceta es un servicio
    panel.grid.major.y = element_line(color = "gray80"),  
    panel.grid.minor.y = element_line(color = "gray90"),  
    axis.line.y = element_line(color = "black")) +  
  labs(title = "Tasas de incidencia de CG por Servicio de Salud", x = "Año", y = "Tasa de incidencia")

incidencias
```

```{r eval = F}
## Exportar figura. NO CORRER OTRA VEZ ESTE CHUNK
ggsave(
  filename = "incidencias_ss.jpeg",
  plot = incidencias,
  width = 10, 
  height = 15, 
  dpi = 300)

```

#5. Pirámide demográfica de tasas de incidencia por quinquenio y sexo.

## 5.1. Incidencias por quinquenio, sexo, SS y AÑO

```{r}
## casos por año, sexo y SS

## Este es el último punto con resultados del objetivo específico 1. para la creación de las pirámides poblacionales de tasas de incidencia de CG se utilizarán las tasas por quinquenio y sexo para cada año y SS



## Paso 1: incidencias por por quinquenio, sexo en cada SS y año.

inc.2 <- RPC %>%
  ## Selección de RPC las variable necesarias
dplyr::select(Servicio_salud, Año_diag, Quinquenios_edad, Sexo) %>%
  
  ## renombrar la variable Año_diag como AÑO
  rename(AÑO = Año_diag) %>%
  
  ## obtener cuantas incidencias hay por año, SS, sexo y quinquenio agrupando por los niveles de estas variables
  group_by(Servicio_salud, Quinquenios_edad, Sexo, AÑO) %>%
  
  ## contar cuantos hay por grupo
  summarise(incidencias = n())

## verificar los nombres de los niveles de quinquenio de edad.
# levels(inc.2$Quinquenios_edad)




## Paso 2: renombrar los niveles de la variable quinquenio
## en el DF de incidencias los niveles de quinquenios están codificados del 1-17. Eso es poco informativo y además no permite enlazar directamente con los niveles del df de poblaciones.

## Objeto que especcifica los niveles de los quinquenios
quinquenios <- c("0-4",      ## = 1
                 "5-9",      ## = 2
                 "10-14",    ## = 3
                 "15-19",    ## = 4
                 "20-24",   ## = 5
                 "25-29",    ## = 6
                 "30-34",    ## = 7
                 "35-39",    ## = 8
                 "40-44",    ## = 9
                 "45-49",    ## = 10
                 "50-54",    ## = 11
                 "55-59",    ## = 12
                 "60-64",    ## = 13
                 "65-69",    ## = 14
                 "70-74",    ## = 15
                 "75-79",    ## = 16
                 "80 y más") ## = 17

## convertir los niveles originales de Quinquenio_edad de inc.2 en los del objeto llamado quinquenio
levels(inc.2$Quinquenios_edad) <- quinquenios
```

## 5.2. Poblaciones por quinquenio, sexo, SS y AÑO

```{r}
## Paso 3: poblaciones por sexo, quinquenio, año y SS.

## Carga de datos poblacion por quinquenio, sexo y comuna
pob.quinquenio <- read_csv("~/Desktop/U_CHILE/MG_BIOESTADÍSTICA/TESIS/DATOS PÚBLICOS/PROYECCIONES_POBLACIONALES/PROYECCION_COMUNA_QUINQUENIO_SEXO.csv") 

## verificar nombres de las columnas del DF
# colnames(pob.quinquenio)

pob.quinquenio <- pob.quinquenio%>%
  
  ## convertir la variable quinquenio en una variable factor llamada Quinquenios_edad. De esta forma tiene el mismo nombre que en el DF de incidencias; se hace lo mismo con la varibale SEXO.
  mutate(Quinquenios_edad = as.factor(quinquenio),
         Sexo = as.factor(`Sexo\r\n1=Hombre\r\n2=Mujer`)) %>%
  
  ## se eliminan del DF las variables originales.
  dplyr::select(-quinquenio,- `Sexo\r\n1=Hombre\r\n2=Mujer`)
  



## Paso 4: añadir variable SS al df de las poblaciones

pob.quinquenio <-  pob.quinquenio %>%
  
## renombrar la variable Comuna como CODIGO_COMUNA. Este último es el nombre que tiene la variable en el df de ServSalud con el cual se ha creado la variable en todos los Scripts.
  mutate(CODIGO_COMUNA = Comuna) %>%
  
  ## Descartar columnas que no se usarán
  dplyr::select(-starts_with("Poblacion 202")) %>%
  dplyr::select(-starts_with("Poblacion 203")) %>%
  dplyr::select(-Comuna)

## juntar el df de pob.quinquenio con el de ServSalud para crear en el primer df la variable de servicio de salud.
pob.quinquenio <- inner_join(pob.quinquenio, ServSalud, by = "CODIGO_COMUNA")




## Paso 5: formato long al df de poablaciones  por quinquenio

pob.quinquenio <- pob.quinquenio %>%
  
  ## eliminar columnas que no se usarán
  dplyr::select(-CODIGO_COMUNA, -`Nombre Comuna`) %>%
  
  ## agrupar según servicio de salud, sexo y quinquenio
  group_by(Servicio_salud, Sexo, Quinquenios_edad) %>%
  
  ## Resumir información en la suma de las columnas
  summarise(across(starts_with("Poblacion"), sum)) %>%
  
  ## Dar formato long al df
  pivot_longer(
    
    #columnas a pasar a formato largo
    cols = starts_with("Poblacion"), # aquellas columnas que empiezan con población
    #nueva columna creada a partir de cols
    names_to = "AÑO",
    #nombre de la columa a crear a partir de los datos de las celdas
    values_to = "POBLACION" ) %>%
  
  ## En la variable año remover el string "Poblacion" y dejando solo el año en formato numeric
  mutate(AÑO = as.numeric(str_remove(AÑO, "Poblacion ")))

## exportar pob.quinquenio
# save(pob.quinquenio, file = "pob_quinquenios_ss.RData")

## Paso 6: unir los df de pob.quinquenio con el de incidencias.

## al df inc.2 se le añadirán las columnas de pob.quinquenio en las filas que coincidan con las variables (comunes en ambos df) de Servicio_salud, Sexo, Quinquenios_edad y AÑO
inc.2 <- left_join(inc.2, 
                   pob.quinquenio, 
                   by = c("Servicio_salud","Sexo","Quinquenios_edad", "AÑO"))




## Paso 7: creación de la tasa

## Creación de la columna tasa como proporcion entre incidencias y poblacion, multiplicada por 100000, y redondeada en dos decimales.
inc.2 <- inc.2 %>%
  mutate(tasa = round((incidencias / POBLACION)*100000,2), ## 100000 = 1e5
         Servicio_salud = as.factor(Servicio_salud),
         AÑO = as.factor(AÑO)) 


 ## RECORDAR QUE EN LA CODIF DEL SEXO: 1 = HOMBRE; 2 = MUJER. SIEMPRE A MENOS QUE SE DIGA LO CONTRARIO

```

## 5.3. Gráfico de pirámide poblacional

```{r eval=F}

## CHUNK YA CORRIDO CON LAS IMÁGENE EN JPEG. NO VOLVER A CORRER.

## eliminar filas con valores NA en df de incidencias
inc.2 <- inc.2 %>%
  drop_na(tasa)

# Transformar los datos para que los hombres tengan valores negativos (necesario para la gráfica)
inc.2$tasa_modificada <- ifelse(inc.2$Sexo == "1", 
                                          -inc.2$tasa, 
                                           inc.2$tasa)


# Listar todos los servicios de salud y años únicos
servicios <- unique(inc.2$Servicio_salud)
años <- unique(inc.2$AÑO)

# Crear una carpeta  en la ruta de trabajo para guardar los gráficos generados
dir.create("graficos_piramides", 
           showWarnings = FALSE)


## creación de gráfico con bucle for anidado para cada combinación de servicio y año

for (servicio in servicios) {      ## para cada servicio en el objeto servicios
  for (año in años) {              ## y para cada año en el obsejto años
    
    ## Filtrar los datos para el servicio y año específicos
       # en cada iteración de los bucles, datos_filtrados es un subconjunto filtrado por la combinación de Servicio_alud y AÑO de la iteración que este corriendo en el momento
       # subset crea un nuevo df que contienen las condiciones especificadas, es decir filtra los SS y AÑO que no correspondan el servicio y año de la iteracion que está corriendo.
    
    datos_filtrados <- subset(inc.2, ## elsu
                              Servicio_salud == servicio & 
                                AÑO == año)
    
    # Crear el gráfico
    p <- ggplot(data = datos_filtrados) +
      
      geom_bar(aes(x = Quinquenios_edad, 
                   y = tasa_modificada, 
                   fill = Sexo), 
               stat = "identity") +
      
      scale_y_continuous(breaks = seq(-900, 1000, 20),
                         labels = abs(seq(-900, 1000, 20))) +
      
      ## voltear los ejer
      coord_flip() +
      
      ## título eje y
      ylab("Tasa de incidencia de CG por 100.000 habitantes") +
      
      ## titulo eje x
      xlab("Quinquenios de edad") +
      
      ## titulo del gráfico
      ## revisar la sintaxis de paste() para entender el código.
      # paste(x1, x2, x3..., sep = " algo ") por default sep = " " separa por un espacio
      ggtitle(paste("Piramide Poblacional:", 
                    servicio,
                    "-", # este guión se utiliza para separar el nombre del servicio y el año en el título del gráfico
                    año)) + 
      
      ## tema del grpafico
      theme_minimal() +
      
      ## especificaciones del tema
      theme(axis.title = element_text(size = 10, 
                                      face = "bold"))
    
    ## Guardar los gráficos en un archivo
    ggsave(paste0("graficos_piramides/", 
                  servicio, "_", 
                  año,
                  ".jpeg"), 
           plot = p,    ## el grafico p que está iterando
           height = 8,  ## altura del grpafico
           width = 10)  ## anchura del grpafico
  }
}
```

```{r eval=F}
## exportar documento para utilizar en el oe2.

incidencias_oe2 <- inc.2 %>%
dplyr::select(Servicio_salud, AÑO, Quinquenios_edad, Sexo, incidencias) %>%
  
  rename(QUINQUENIO = Quinquenios_edad,
         SEXO = Sexo) %>%
  write_csv("incidencias_oe2.csv")

## objeto llevado a la carpeta del OE2
incidencias_oe2
```
